# Методы упорядочивания и нахождения данных

## 1. Метод последовательного отбора элементов

**Общая характеристика:** Данный подход к систематизации информации представляет собой базовую методику, при которой обрабатываемый набор данных последовательно разделяется на две области: упорядоченную и необработанную.

**Принцип действия:** На каждом этапе обработки алгоритм определяет наименьший элемент в необработанной области и производит его замену с начальным элементом этой зоны, тем самым перемещая его в завершающую часть систематизированного раздела.

**Последовательность операций:**
Изначально отображается исходный набор данных.
Затем выполняется систематизация методом последовательного выбора, после чего повторно выводится уже упорядоченный массив информации.
Для удобства восприятия и понимания процесса используются вспомогательные операции (обмен значений и вывод массива).

**Вычислительная эффективность:** Эффективность данного метода составляет O(n²) даже при наиболее благоприятных условиях. Детальный анализ показывает: алгоритм consistently выполняет приблизительно n²/2 операций сравнения и n операций обмена. 
Внешний цикл повторяется n-1 раз, внутренний цикл выполняется (n-i) раз для каждого i, что дает суммарное количество сравнений: Σ(n-i) = n(n-1)/2 ≈ O(n²).

**Практическая демонстрация:**
Первоначальный набор: [64 25 12 22 11]
Упорядоченный набор: [11 12 22 25 64]

## 2. Метод попарного сравнения соседних элементов

**Общая характеристика:** Это фундаментальный подход к систематизации, основанный на последовательном сравнении смежных элементов набора данных и их взаимной замене при нарушении требуемого порядка расположения.

**Принцип действия:** Алгоритм многократно проходит через обрабатываемый список, сопоставляя соседние элементы и осуществляя их перестановку при обнаружении неправильной последовательности. 
Процесс повторяется до достижения полной упорядоченности всего списка.

**Последовательность операций:**
Внешний цикл обрабатывает каждый элемент списка.
Внутренний цикл сравнивает смежные элементы и производит их перестановку при нарушении правильной последовательности.
Если в течение одного полного прохода не было выполнено ни одной перестановки, это свидетельствует о достижении полной упорядоченности списка, и алгоритм завершает работу.

**Вычислительная эффективность:** Временная эффективность метода попарного сравнения составляет O(n²). В наихудшем сценарии требуется n-1 проходов, на i-м проходе выполняется n-i сравнений. 
Общее количество операций сравнения: Σ(n-i) = n(n-1)/2 ≈ O(n²). При использовании оптимизации (индикатор перестановок) наилучший случай достигает O(n).

**Практическая демонстрация:** 
Исходный набор [64, 34, 25, 12, 22, 11, 90]
Упорядоченный набор [11, 12, 22, 25, 34, 64, 90]

## 3. Метод поэтапного включения элементов

**Общая характеристика:** Это элементарный алгоритм, который формирует упорядоченный массив путем постепенного расширения его размерности.

**Принцип действия:** Алгоритм строит систематизированный раздел списка, последовательно включая каждый элемент в соответствующую позицию. Он начинает с первого элемента и продвигается вправо, 
сопоставляя каждый элемент с предыдущими и размещая его в правильном положении.

**Последовательность операций:**
Алгоритм проходит через массив, начиная со второго элемента. 
Для каждого элемента определяется корректная позиция в уже упорядоченной части массива и производится его включение в это место.

**Вычислительная эффективность:** В наихудшем сценарии каждый новый элемент требует перемещения всех элементов упорядоченной части. Количество сравнений и перемещений: Σi = n(n-1)/2 ≈ O(n²). В наилучшем случае требуется только n-1 сравнений.

**Практическая демонстрация:**
Исходный набор [12, 11, 13, 5, 6]
Упорядоченный набор [5, 6, 11, 12, 13]

## 4. Метод рекурсивного объединения упорядоченных частей

**Общая характеристика:** Это результативный алгоритм систематизации, использующий рекурсивный подход, работающий по принципу последовательного разделения и объединения. 

**Принцип действия:** Он рекурсивно разделяет массив на две равные части, систематизирует каждую половину отдельно, а затем объединяет упорядоченные половины в единый систематизированный массив.

**Последовательность операций:**
Массив рекурсивно делится на две половины до достижения состояния, когда каждая половина содержит один элемент.
Затем упорядоченные половины объединяются в единый систематизированный массив.

**Вычислительная эффективность:** O(n log n) — где n — количество элементов в массиве. Время работы описывается рекуррентным соотношением T(n) = 2T(n/2) + O(n). Алгоритм требует дополнительной памяти для процесса объединения.

**Практическая демонстрация:**
Исходный набор: [38, 27, 43, 3, 9, 82, 10]
Упорядоченный набор: [3, 9, 10, 27, 38, 43, 82]

## 5. Метод постепенно уменьшающихся интервалов

**Общая характеристика:** Это обобщение алгоритма поэтапного включения, который систематизирует элементы, расположенные на определенном расстоянии друг от друга. 

**Принцип действия:** Изначально сравнивает и упорядочивает элементы, находящиеся на некотором расстоянии друг от друга (грубые проходы), а затем постепенно сокращает это расстояние. 
Финальный проход выполняется с расстоянием, равным (1), что преобразует алгоритм в стандартный метод поэтапного включения для практически упорядоченного массива. 

**Последовательность операций:**
Выбор интервала: первоначально интервал равен половине длины массива, затем постепенно уменьшается.
Поэтапное включение: на каждом шаге выполняется метод поэтапного включения для элементов, находящихся на расстоянии интервала.
Сокращение интервала: Интервал уменьшается до достижения значения 1, после чего выполняется стандартный метод поэтапного включения.

**Вычислительная эффективность:** O(n^{3/2}) — в среднем. Эффективность существенно зависит от выбора последовательности интервалов. Для последовательности Кнута эффективность O(n^(3/2)), для последовательности Седжвика O(n^(4/3)). 

**Практическая демонстрация:**
Исходный набор: [23, 12, 1, 8, 34, 54, 2, 3]
Упорядоченный набор: [1, 2, 3, 8, 12, 23, 34, 54]

## 6. Метод быстрого упорядочивания

**Общая характеристика:** Один из наиболее известных и широко применяемых алгоритмов систематизации. Это эффективный метод упорядочивания, работающий по принципу последовательного разделения и объединения.

**Принцип действия:** Алгоритм заключается в выборе центрального элемента, разделении массива на две части относительно центрального (одна — все элементы, меньшие центрального элемента, вторая — большие),
и в систематизации полученных частей рекурсивным обращением к самому себе.

**Последовательность операций:**
Алгоритм быстрого упорядочивания работает по принципу "разделяй и властвуй". Он выбирает центральный элемент, разделяет массив на две части (элементы меньше центрального и элементы больше центрального), 
а затем рекурсивно систематизирует обе части.

**Вычислительная эффективность:** Средняя временная эффективность: O(n log n). В среднем случае время работы описывается как T(n) = 2T(n/2) + O(n) = O(n log n). 
В наихудшем случае (уже упорядоченный массив) T(n) = T(n-1) + O(n) = O(n²).

**Практическая демонстрация:**
Исходный набор: [10 7 8 9 1 5]
Упорядоченный набор: [1 5 7 8 9 10]

## 7. Метод древовидной систематизации

**Общая характеристика:** Это алгоритм упорядочивания, основанный на использовании структуры данных «иерархическое дерево».

**Принцип действия:** Основная концепция заключается в том, чтобы первоначально построить из массива двоичное иерархическое дерево (обычно max-heap), а затем последовательно извлекать максимальный элемент и размещать его в конце массива,
уменьшая размер дерева на единицу.

**Последовательность операций:**
Функция поддержания структуры: операция, которая сохраняет свойства иерархического дерева (max-heap), перемещая наибольший элемент вверх.
Процесс древовидной систематизации: сначала строит max-heap из массива, затем последовательно извлекает максимальный элемент и помещает его в конец массива, уменьшая размер дерева.

**Вычислительная эффективность:**
Средняя и наихудшая эффективность: O(n \log n). Построение дерева занимает O(n) времени. Каждое из n извлечений максимума требует O(log n) времени для перестройки дерева. Итого: O(n) + n × O(log n) = O(n log n).

**Практическая демонстрация:**
Исходный набор: [12, 11, 13, 5, 6, 7]
Упорядоченный набор: [5, 6, 7, 11, 12, 13]

## 8. Метод последовательного просмотра

**Общая характеристика:** Это элементарный алгоритм, который последовательно перебирает элементы списка, сопоставляя их с искомым значением. 

**Принцип действия:** Это алгоритм, который осуществляет поиск заданного элемента, последовательно проверяя каждый элемент коллекции (например, массива) от начала до конца. 
Данный метод является простейшим и не требует предварительной систематизации данных.

**Последовательность операций:**
Операция последовательного просмотра принимает два аргумента: список данных и искомое значение.
Алгоритм последовательно перебирает элементы списка, проверяя соответствие текущего элемента искомому значению.
При обнаружении соответствия возвращается индекс элемента.
Если элемент не обнаружен после полного перебора, возвращается -1.

**Вычислительная эффективность** последовательного просмотра составляет O(n), где (n) — количество элементов в массиве. Это означает, что в наихудшем случае алгоритму потребуется проверить все элементы, 
чтобы обнаружить искомое значение или убедиться в его отсутствии. 

**Практическая демонстрация:**
Исходный набор: [4, 2, 7, 1, 9]
Результат: Элемент 7 обнаружен на позиции 2

## 9. Метод половинного деления

**Общая характеристика:** Это поиск заданного элемента на упорядоченном множестве, осуществляемый путём многократного разделения этого множества на две части таким образом,
что искомый элемент попадает в одну из этих частей. 

**Принцип действия:** Поиск завершается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. 
Преимуществом метода половинного деления является сниженная трудоёмкость по сравнению с последовательным просмотром. Ограничение заключается в том, что он применим только на упорядоченных множествах.

**Последовательность операций:**
Массив предварительно систематизируется (уже упорядочен). Каждый раз проверяется центральный элемент массива. Если целевой элемент соответствует центральному, выводится индекс.
Если цель меньше центрального значения, дальнейший поиск осуществляется в левой части массива. Если цель больше центрального значения, поиск продолжается в правой части. 
Процесс повторяется до обнаружения элемента или установления его отсутствия.

**Вычислительная эффективность:** O(log n) поскольку на каждой итерации массив делится строго пополам, сокращая область поиска вдвое. 
Количество итераций пропорционально количеству двоичных делений размера массива, что выражается логарифмом по основанию 2 от числа элементов.

**Практическая демонстрация:**
Исходный набор: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат выполнения: Элемент обнаружен на позиции 5

## 10. Метод пропорционального приближения

**Общая характеристика:** Это алгоритм поиска, который совершенствует метод половинного деления за счет более точной оценки позиции искомого элемента, используя его значение относительно диапазона данных.

**Принцип действия:** Метод пропорционального приближения аналогичен половинному делению, но вычисляет следующую позицию поиска не просто в середине, а исходя из предположения о равномерном распределении значений. 
Данная стратегия позволяет быстрее обнаруживать элементы в крупных равномерно распределённых наборах данных.

**Последовательность операций:** Массив должен быть предварительно упорядоченным. Алгоритм пытается оценить положение искомого элемента путём расчёта приблизительной позиции, учитывая распределение элементов.
После оценки выполняется проверка расчетного элемента. Если искомое значение меньше расчетного, рассматривается нижняя половина массива, иначе верхняя. 
Повторяется до тех пор, пока не обнаружится элемент или не станет очевидным его отсутствие.

**Вычислительная эффективность:** Временная эффективность интерполяционного поиска составляет (O(log (log (n)))) в среднем случае при равномерном распределении данных, что превосходит метод половинного деления ((O(log (n)))). 
Однако в наихудшем случае (при неравномерном распределении) эффективность может достигать O(n), как у последовательного просмотра. 

**Практическая демонстрация:**
Исходный набор: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
Результат выполнения: Элемент обнаружен на позиции 5

## 11. Метод числовой последовательности

**Общая характеристика:** Метод числовой последовательности — это способ быстрого поиска элемента в упорядоченном списке или метод определения экстремума функции в заданном интервале, использующий специальные числовые последовательности для разделения массива или интервала на части.

**Принцип действия:** Поиск по числовой последовательности представляет собой модификацию метода половинного деления, где массив разделяется не пополам, а на основании специальных числовых последовательностей. 
Основная концепция заключается в выборе точки разделения таким образом, чтобы длина оставшихся частей соответствовала двум ближайшим числам специальной последовательности.

**Последовательность операций:** Изначально генерируются числа специальной последовательности, начиная с небольших значений, и выбирается первое число, превышающее длину массива. 
Затем выполняется сравнение элемента в выбранной точке массива с искомым элементом.
На основе результата сравнения перемещаются границы поиска и повторно применяется логика специальной последовательности для выбора новой точки разделения. 
Процесс продолжается до тех пор, пока не обнаружится элемент или не станет ясным его отсутствие в массиве.

**Вычислительная эффективность:** временная эффективность вычислений специальной последовательности зависит от алгоритма: базовая рекурсивная реализация имеет экспоненциальную эффективность (O(2^{n})) из-за многократного пересчета значений, 
тогда как итеративный подход или использование запоминания (динамическое программирование) существенно снижают её до линейной (O(n)). 
Поиск по специальной последовательности (как алгоритм поиска) имеет временную эффективность (O(log n)), а для конкретной задачи — (O(n)) в наихудшем случае. 

**Практическая демонстрация:**
Исходный набор: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Результат выполнения: Элемент обнаружен на позиции: 8
