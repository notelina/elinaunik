Вариант 1. Напишите рекурсивную функцию для вычисления суммы цифр числа
**Рекурсивная функция для вычисления суммы цифр числа**

**Принцип работы алгоритма:**

Алгоритм использует рекурсивный подход для разбиения задачи на более мелкие подзадачи. Основная идея заключается в том, что сумма цифр числа равна последней цифре числа плюс сумма цифр оставшейся части числа (без последней цифры).

**Шаги выполнения:**

1. **Базовый случай**: Если число меньше 10, значит оно состоит из одной цифры, и мы просто возвращаем это число как результат.

2. **Рекурсивный случай**: Для чисел больше или равных 10:
   - Отделяем последнюю цифру числа с помощью операции взятия остатка от деления на 10 (`n % 10`)
   - Получаем оставшуюся часть числа с помощью целочисленного деления на 10 (`n // 10`)
   - Рекурсивно вызываем функцию для оставшейся части и прибавляем к ней последнюю цифру

**Пример для числа 345:**
```
sum_digits(345) = 5 + sum_digits(34)
sum_digits(34) = 4 + sum_digits(3)
sum_digits(3) = 3 (базовый случай)

Результат: 5 + 4 + 3 = 12
```

**Временная сложность: O(d)**, где d - количество цифр в числе.

**Объяснение сложности:**
- Количество рекурсивных вызовов равно количеству цифр в числе
- Каждая операция (взятие остатка, деление, сложение) выполняется за постоянное время O(1)
- Таким образом, общая сложность линейно зависит от количества цифр в числе

Для числа n количество цифр d ≈ log₁₀(n), поэтому сложность можно также выразить как O(log n).
. Какая разница между обходом дерева в глубину (DFS) и в ширину (BFS)?
**Разница между обходом дерева в глубину (DFS) и в ширину (BFS)**

**Основное концептуальное отличие** заключается в направлении обхода: DFS движется вертикально — от корня к самым глубоким узлам, прежде чем исследовать соседние ветви, тогда как BFS движется горизонтально — обходит все узлы текущего уровня перед переходом на следующий уровень.

**Стратегия поиска:** 
- DFS следует стратегии "иди до конца" — при достижении узла алгоритм продолжает углубляться по первой доступной ветви, пока не достигнет листа, после чего возвращается к последней точке выбора
- BFS придерживается принципа "расширяйся равномерно" — обрабатывает все дочерние узлы текущего уровня, прежде чем перейти к узлам следующего уровня

**Используемые структуры данных:** 
DFS использует стек, что может быть реализовано либо явно, либо через рекурсивные вызовы функций. BFS использует очередь, что обеспечивает порядок "первым пришел — первым ушел".

**Требования к памяти:** 
DFS обычно требует меньше памяти, так как хранит только путь от корня до текущего узла. BFS потребляет значительно больше памяти, особенно для широких деревьев, поскольку должен хранить все узлы текущего уровня.

**Области применения:** 
DFS эффективен для задач, где нужно найти любое решение или проверить существование пути, а также когда дерево очень широкое. BFS предпочтителен для поиска кратчайшего пути в немвзвешенном графе, поиска ближайших соседей или когда дерево очень глубокое.

**Порядок обхода** демонстрирует фундаментальное различие: DFS сначала полностью исследует одну ветвь, тогда как BFS равномерно продвигается по всем направлениям одновременно, что гарантирует нахождение кратчайшего пути при его существовании.
