**Сортировка выбором (Selection Sort)**

**Определение**
Сортировка выбором — это простой алгоритм сортировки, который последовательно находит минимальный (или максимальный) элемент в неотсортированной части массива и помещает его в начало этой части. Алгоритм работает "на месте" (in-place) и не требует дополнительной памяти.

**Пошаговый алгоритм**

1. **Инициализация**: Установить начальную позицию `i = 0`
2. **Поиск минимума**: В неотсортированной части массива (от `i` до `n-1`) найти индекс минимального элемента
3. **Обмен**: Поменять местами найденный минимальный элемент с элементом на позиции `i`
4. **Сдвиг границы**: Увеличить `i` на 1, сократив тем самым неотсортированную часть
5. **Повторение**: Повторять шаги 2-4, пока `i < n-1`

**Пример работы**

Исходный массив: `[64, 25, 12, 22, 11]`

**Первый проход:**
- Неотсортированная часть: `[64, 25, 12, 22, 11]`
- Минимальный элемент: `11` (индекс 4)
- Меняем местами с элементом на позиции 0: `[11, 25, 12, 22, 64]`

**Второй проход:**
- Неотсортированная часть: `[25, 12, 22, 64]`
- Минимальный элемент: `12` (индекс 2)
- Меняем местами с элементом на позиции 1: `[11, 12, 25, 22, 64]`

**Третий проход:**
- Неотсортированная часть: `[25, 22, 64]`
- Минимальный элемент: `22` (индекс 3)
- Меняем местами с элементом на позиции 2: `[11, 12, 22, 25, 64]`

**Четвертый проход:**
- Неотсортированная часть: `[25, 64]`
- Минимальный элемент: `25` (индекс 3)
- Меняем местами с элементом на позиции 3: `[11, 12, 22, 25, 64]`

**Результат:** `[11, 12, 22, 25, 64]`

**Псевдокод**
```
for i = 0 to n-2:
    min_index = i
    for j = i+1 to n-1:
        if array[j] < array[min_index]:
            min_index = j
    swap(array[i], array[min_index])
```

Временная сложность

- **Худший случай:** O(n²) - массив отсортирован в обратном порядке
- **Лучший случай:** O(n²) - даже для отсортированного массива
- **Средний случай:** O(n²)

**Объяснение сложности:**
- Количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)
- Количество обменов: n-1 = O(n)

**Пространственная сложность:** O(1) - алгоритм работает "на месте"

**Преимущества:**
- Простота реализации
- Минимальное количество обменов (O(n))
- Работает на месте без дополнительной памяти

**Недостатки:**
- Квадратичная временная сложность
- Неустойчив (может менять порядок одинаковых элементов)
- Не адаптивен (не ускоряется на частично отсортированных массивах)
 вариант 10 контрольный вопрос
Вариант 10. Жадный алгоритм для выбора задач (Task Selection)
**Жадный алгоритм для выбора задач (Task Selection)**

**Определение**
Жадный алгоритм выбора задач — это алгоритм планирования, который выбирает задачи в порядке их завершения (по возрастанию времени окончания). Этот подход гарантирует максимальное количество неконфликтующих задач, которые можно выполнить за определенный период времени.

**Пошаговый алгоритм**

1. **Сортировка**: Отсортировать все задачи по времени их завершения
2. **Инициализация**: Выбрать первую задачу из отсортированного списка
3. **Выбор следующих задач**: Для каждой последующей задачи:
   - Если время начала задачи больше или равно времени окончания последней выбранной задачи
   - Добавить эту задачу в результат

**Пример работы**

Исходный список задач: `[(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11)]`
(где первое число - время начала, второе - время окончания)

**Шаг 1 - Сортировка по времени окончания:**
`[(1, 4), (3, 5), (0, 6), (5, 7), (3, 8), (5, 9), (6, 10), (8, 11)]`

**Шаг 2 - Выбор задач:**
- Выбираем задачу 1: `(1, 4)` - время окончания = 4
- Следующая задача `(3, 5)` - начинается в 3 (раньше окончания предыдущей) - пропускаем
- Следующая задача `(0, 6)` - начинается в 0 (раньше окончания предыдущей) - пропускаем
- Следующая задача `(5, 7)` - начинается в 5 (≥ 4) - ВЫБИРАЕМ
- Следующая задача `(3, 8)` - начинается в 3 (раньше окончания предыдущей) - пропускаем
- Следующая задача `(5, 9)` - начинается в 5 (раньше окончания предыдущей) - пропускаем
- Следующая задача `(6, 10)` - начинается в 6 (≥ 7) - ВЫБИРАЕМ
- Следующая задача `(8, 11)` - начинается в 8 (≥ 10) - ВЫБИРАЕМ

**Результат:** `[(1, 4), (5, 7), (6, 10), (8, 11)]` - 4 задачи

**Псевдокод**
```
function taskSelection(tasks):
    // Сортируем задачи по времени окончания
    sort(tasks by end_time)
    
    selected_tasks = []
    last_end_time = -∞
    
    for each task in tasks:
        if task.start_time >= last_end_time:
            selected_tasks.append(task)
            last_end_time = task.end_time
    
    return selected_tasks
```

**Временная сложность**

- **Сортировка:** O(n log n) - быстрая сортировка или сортировка слиянием
- **Выбор задач:** O(n) - один проход по отсортированному списку
- **Общая сложность:** O(n log n)

**Пространственная сложность:** O(1) или O(n) в зависимости от реализации

**Доказательство оптимальности**
Алгоритм является оптимальным, потому что:
1. Выбор задачи с наименьшим временем окончания оставляет максимальное время для последующих задач
2. Любое другое решение не может содержать больше задач

**Преимущества:**
- Гарантирует оптимальное решение
- Прост в реализации
- Эффективен по времени

**Недостатки:**
- Не учитывает приоритеты или веса задач
- Не подходит для задач с разной продолжительностью или важностью

**Области применения:**
- Планирование занятий в аудиториях
- Расписание мероприятий
- Аллокация ресурсов
- Планирование процессов в операционных системах
